@using PhotoSwipe.Blazor.Models
@using PhotoSwipe.Blazor.Services
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Logging
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject ILogger<PhotoSwipeUploadArea> Logger

<div class="photoswipe-upload-area @CssClass">
    <!-- Upload Header -->
    <div class="upload-header">
        <h3 class="upload-title">@(AllowDocuments ? "üìÅ Upload Files" : "üì∏ Upload Images")</h3>
        <div class="upload-info">
            <span class="file-types">üìÑ Supported: @string.Join(", ", GetSupportedTypes())</span>
            <span class="size-limit">üìè Max: @FormatFileSize(MaxFileSize) per file</span>
        </div>
    </div>

    <!-- Upload Area -->
    <div class="upload-area @(_isDragOver ? "drag-over" : "")"
         @ondragenter="OnDragEnter"
         @ondragleave="OnDragLeave"
         @ondragover="OnDragOver"
         @ondragover:preventDefault="true"
         @ondrop="OnDrop"
         @ondrop:preventDefault="true">

        <!-- Use a label that wraps the InputFile for native browser behavior -->
        <label class="upload-label" style="cursor: pointer; display: block; width: 100%; height: 100%;">
            <InputFile @ref="inputFileRef"
                      OnChange="OnFilesSelected"
                      multiple="@AllowMultipleFiles"
                      accept="@GetAcceptString()"
                      disabled="@DisableDragDrop"
                      style="display: none;" />

            <div class="upload-prompt">
                <div class="upload-icon">üìÅ</div>
                <div class="upload-text">
                    <p class="primary-text">Drop @(AllowMultipleFiles ? (AllowDocuments ? "files" : "images") : (AllowDocuments ? "a file" : "an image")) here or click to select</p>
                    <p class="secondary-text">@(AllowMultipleFiles ? $"You can select multiple {(AllowDocuments ? "files" : "images")} at once" : $"Select a single {(AllowDocuments ? "file" : "image")}")</p>
                </div>
            </div>
        </label>
    </div>

    <!-- Processing Status -->
    @if (_isProcessing)
    {
        <div class="processing-status">
            <div class="loading-spinner"></div>
            <span>Processing @_processingCount of @_totalFiles files...</span>
        </div>
    }

    <!-- Upload Controls -->
    @if (_uploadedItems.Any() && !_isProcessing)
    {
        <div class="upload-controls">
            <div class="upload-stats">
                @_uploadedItems.Count file(s) ready to add
            </div>
            <div class="upload-buttons">
                <label class="upload-mode">
                    <input type="radio" name="uploadMode-@ElementId" checked="@(UploadMode == PhotoSwipeUploadMode.Add)" @onchange="@(() => SetUploadMode(PhotoSwipeUploadMode.Add))" />
                    Add to Gallery
                </label>
                <label class="upload-mode">
                    <input type="radio" name="uploadMode-@ElementId" checked="@(UploadMode == PhotoSwipeUploadMode.Replace)" @onchange="@(() => SetUploadMode(PhotoSwipeUploadMode.Replace))" />
                    Replace Gallery
                </label>
                <button class="btn-confirm" @onclick="ConfirmUpload" disabled="@_isProcessing">
                    ‚úÖ Confirm Upload
                </button>
                <button class="btn-cancel" @onclick="ClearUpload">
                    ‚ùå Cancel
                </button>
            </div>
        </div>
    }

    <!-- Error Messages -->
    @if (_errorMessages.Any())
    {
        <div class="error-messages">
            @foreach (var error in _errorMessages)
            {
                <div class="error-message @(error.IsCloudStorageIssue ? "cloud-storage-error" : "")">
                    <div class="error-header">
                        <span class="error-icon">‚ö†Ô∏è</span>
                        <span class="error-filename">@error.FileName</span>
                        <span class="error-type">(@error.ErrorType)</span>
                    </div>
                    <div class="error-body">
                        <p class="error-main-message">@error.Message</p>
                        @if (!string.IsNullOrEmpty(error.SuggestedAction))
                        {
                            <p class="error-suggestion">üí° @error.SuggestedAction</p>
                        }
                        @if (error.IsCloudStorageIssue)
                        {
                            <p class="error-cloud-storage-hint">
                                ‚òÅÔ∏è <strong>Cloud Storage Detected:</strong> This file may be stored in OneDrive, Google Drive, or similar cloud storage.
                                Please download it to your local computer first, then try uploading again.
                            </p>
                        }
                    </div>
                </div>
            }
            <button class="btn-clear-errors" @onclick="ClearErrors">Clear Errors</button>
        </div>
    }

    <!-- Upload Preview -->
    @if (_uploadedItems.Any() && !_isProcessing)
    {
        <div class="upload-preview">
            <h4>Preview (@_uploadedItems.Count files):</h4>
            <div class="preview-grid">
                @foreach (var item in _uploadedItems)
                {
                    <div class="preview-item">
                        <img src="@item.ThumbnailUrl" alt="@item.Alt" class="preview-thumbnail" />
                        <div class="preview-info">
                            <span class="preview-name">@item.Title</span>
                            <span class="preview-size">@item.Width√ó@item.Height</span>
                        </div>
                        <button class="btn-remove" @onclick="() => RemoveUploadedItem(item)">√ó</button>
                    </div>
                }
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public string? Id { get; set; }
    [Parameter] public string? CssClass { get; set; }

    // Upload configuration parameters
    [Parameter] public PhotoSwipeUploadMode UploadMode { get; set; } = PhotoSwipeUploadMode.Add;
    [Parameter] public long MaxFileSize { get; set; } = 10 * 1024 * 1024; // 10MB
    [Parameter] public int MaxFiles { get; set; } = 20;
    [Parameter] public bool AllowMultipleFiles { get; set; } = true;
    [Parameter] public bool DisableDragDrop { get; set; } = false;
    [Parameter] public bool AllowDocuments { get; set; } = false;

    // Event callbacks
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsUploaded { get; set; }
    [Parameter] public EventCallback<PhotoSwipeUploadMode> OnUploadModeChanged { get; set; }
    [Parameter] public EventCallback<PhotoSwipeFileError> OnFileError { get; set; }
    [Parameter] public EventCallback<PhotoSwipeUploadResult> OnUploadComplete { get; set; }

    // Internal state
    private ImageProcessingService? _imageProcessor;
    private InputFile? inputFileRef;
    private readonly List<PhotoSwipeItem> _uploadedItems = [];
    private readonly List<PhotoSwipeFileError> _errorMessages = [];
    private bool _isProcessing = false;
    private bool _isDragOver = false;
    private int _processingCount = 0;
    private int _totalFiles = 0;

    // Generate a unique element ID for radio button grouping
    private string ElementId => Id ?? $"upload-area-{GetHashCode():X}";

    protected override void OnInitialized()
    {
        _imageProcessor = new ImageProcessingService(JS);
    }

    private async Task OnFilesSelected(InputFileChangeEventArgs e)
    {
        Logger.LogInformation("OnFilesSelected called with {FileCount} files", e.FileCount);

        IEnumerable<IBrowserFile> files;
        if (AllowMultipleFiles)
        {
            files = e.GetMultipleFiles(MaxFiles);
        }
        else
        {
            // For single file mode, only take the first file
            files = e.FileCount > 0 ? new[] { e.File } : Enumerable.Empty<IBrowserFile>();
        }

        await ProcessFiles(files);
    }

    private async Task ProcessFiles(IEnumerable<IBrowserFile> files)
    {
        _isProcessing = true;
        _processingCount = 0;
        _totalFiles = files.Count();
        _errorMessages.Clear();

        try
        {
            Logger.LogInformation("Processing {FileCount} uploaded files", _totalFiles);

            var successfulItems = new List<PhotoSwipeItem>();
            var errors = new List<PhotoSwipeFileError>();

            foreach (var file in files)
            {
                _processingCount++;
                StateHasChanged(); // Update progress

                // Use Try* methods for proper error handling
                var result = AllowDocuments
                    ? await _imageProcessor!.TryProcessFileAsync(file, MaxFileSize)
                    : await _imageProcessor!.TryProcessImageFileAsync(file, MaxFileSize);

                if (result.Item != null)
                {
                    successfulItems.Add(result.Item);
                    Logger.LogDebug("Processed file: {FileName}", file.Name);
                }
                else if (result.Error != null)
                {
                    errors.Add(result.Error);
                    _errorMessages.Add(result.Error);

                    // Invoke per-file error callback
                    if (OnFileError.HasDelegate)
                    {
                        await OnFileError.InvokeAsync(result.Error);
                    }

                    Logger.LogWarning("Error processing file {FileName}: {ErrorType} - {Message}",
                        file.Name, result.Error.ErrorType, result.Error.Message);
                }
            }

            _uploadedItems.AddRange(successfulItems);
            Logger.LogInformation("Successfully processed {SuccessCount}/{TotalCount} files, _uploadedItems now has {UploadedCount} items",
                successfulItems.Count, _totalFiles, _uploadedItems.Count);

            // Invoke upload complete callback with full result
            if (OnUploadComplete.HasDelegate)
            {
                var uploadResult = PhotoSwipeUploadResult.Create(successfulItems, errors);
                await OnUploadComplete.InvokeAsync(uploadResult);
            }
        }
        finally
        {
            _isProcessing = false;
            StateHasChanged();
        }
    }

    private async Task ConfirmUpload()
    {
        if (!_uploadedItems.Any()) return;

        var uploadedItems = _uploadedItems.ToList();
        _uploadedItems.Clear();

        if (OnItemsUploaded.HasDelegate)
        {
            await OnItemsUploaded.InvokeAsync(uploadedItems);
        }

        StateHasChanged();
        Logger.LogInformation("Confirmed upload of {ItemCount} items", uploadedItems.Count);
    }

    private void ClearUpload()
    {
        _uploadedItems.Clear();
        _errorMessages.Clear();
        StateHasChanged();
    }

    private void RemoveUploadedItem(PhotoSwipeItem item)
    {
        _uploadedItems.Remove(item);
        StateHasChanged();
    }

    private void ClearErrors()
    {
        _errorMessages.Clear();
        StateHasChanged();
    }

    private async Task SetUploadMode(PhotoSwipeUploadMode mode)
    {
        UploadMode = mode;
        if (OnUploadModeChanged.HasDelegate)
        {
            await OnUploadModeChanged.InvokeAsync(mode);
        }
        StateHasChanged();
    }

    // Event handlers
    private void OnDragEnter() => _isDragOver = true;
    private void OnDragLeave() => _isDragOver = false;
    private void OnDragOver(DragEventArgs e) => e.DataTransfer.DropEffect = "copy";

    private void OnDrop(DragEventArgs e)
    {
        _isDragOver = false;

        // Note: DataTransfer.Files from DragEventArgs are filenames, not IBrowserFile
        // Real drag & drop file processing needs to be handled differently
        // For now, we'll just reset the drag state
        StateHasChanged();
    }

    // Helper methods
    private string[] GetSupportedTypes() => AllowDocuments
        ? ImageProcessingService.GetAllSupportedTypes()
        : ImageProcessingService.GetSupportedTypes();

    private string GetAcceptString() => AllowDocuments
        ? ImageProcessingService.GetAllFilesAcceptString()
        : ImageProcessingService.GetFileAcceptString();

    private static string FormatFileSize(long bytes) => ImageProcessingService.FormatFileSize(bytes);

    public async ValueTask DisposeAsync()
    {
        // Component cleanup if needed
        await Task.CompletedTask;
    }
}