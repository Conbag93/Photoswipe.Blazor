@using Microsoft.AspNetCore.Components
@using Microsoft.AspNetCore.Components.Web

<div class="photoswipe-overlay-control @GetPositionClass() @CssClass"
     data-pswp-overlay-control="true"
     data-pswp-control-type="@ControlType"
     data-pswp-prevent-gallery="true"
     style="@GetPositionStyle()"
     @attributes="AdditionalAttributes">

    @if (ChildContent != null)
    {
        @ChildContent
    }
    else if (!string.IsNullOrEmpty(Icon))
    {
        <button type="button"
                class="overlay-control-button @ButtonCssClass"
                style="@GetButtonSizeStyle()"
                @onclick="OnClick"
                @onclick:preventDefault="PreventDefault"
                @onclick:stopPropagation="StopPropagation"
                disabled="@Disabled"
                title="@Title"
                aria-label="@(AriaLabel ?? Title)">
            @if (Icon.StartsWith('<'))
            {
                @((MarkupString)Icon)
            }
            else
            {
                @Icon
            }
        </button>
    }
</div>

@code {
    /// <summary>
    /// Overlay control position options
    /// </summary>
    public enum OverlayPosition
    {
        TopLeft,
        TopRight,
        TopCenter,
        BottomLeft,
        BottomRight,
        BottomCenter,
        CenterLeft,
        CenterRight,
        Center,
        Custom
    }

    /// <summary>
    /// Direction to grow when multiple controls share the same position
    /// </summary>
    public enum GrowDirection
    {
        Auto,
        Right,
        Left,
        Down,
        Up
    }

    /// <summary>
    /// Position of the overlay control relative to the gallery item
    /// Only used when not inside a PhotoSwipeOverlayControlGroup
    /// </summary>
    [Parameter] public OverlayPosition Position { get; set; } = OverlayPosition.TopRight;

    /// <summary>
    /// Type of control for semantic identification
    /// </summary>
    [Parameter] public string ControlType { get; set; } = "custom";

    /// <summary>
    /// Icon to display (can be text, emoji, or HTML markup)
    /// </summary>
    [Parameter] public string? Icon { get; set; }

    /// <summary>
    /// Custom child content (overrides Icon)
    /// </summary>
    [Parameter] public RenderFragment? ChildContent { get; set; }

    /// <summary>
    /// Click event handler
    /// </summary>
    [Parameter] public EventCallback<MouseEventArgs> OnClick { get; set; }

    /// <summary>
    /// Whether to prevent default click behavior
    /// </summary>
    [Parameter] public bool PreventDefault { get; set; } = true;

    /// <summary>
    /// Whether to stop click event propagation
    /// </summary>
    [Parameter] public bool StopPropagation { get; set; } = true;

    /// <summary>
    /// Whether the control is disabled
    /// </summary>
    [Parameter] public bool Disabled { get; set; } = false;

    /// <summary>
    /// Tooltip text for the control
    /// </summary>
    [Parameter] public string? Title { get; set; }

    /// <summary>
    /// Accessibility label for screen readers
    /// </summary>
    [Parameter] public string? AriaLabel { get; set; }

    /// <summary>
    /// Additional CSS classes for the container
    /// </summary>
    [Parameter] public string? CssClass { get; set; }

    /// <summary>
    /// Additional CSS classes for the button element
    /// </summary>
    [Parameter] public string? ButtonCssClass { get; set; }

    /// <summary>
    /// Custom offset from the edge (in CSS units like px, rem, etc.)
    /// </summary>
    [Parameter] public string? Offset { get; set; }

    /// <summary>
    /// Custom positioning styles
    /// </summary>
    [Parameter] public string? CustomPosition { get; set; }


    /// <summary>
    /// Button size in pixels - defaults to responsive values (40px desktop, 44px mobile)
    /// </summary>
    [Parameter] public int? ButtonSize { get; set; }

    /// <summary>
    /// Additional HTML attributes
    /// </summary>
    [Parameter(CaptureUnmatchedValues = true)]
    public Dictionary<string, object>? AdditionalAttributes { get; set; }

    /// <summary>
    /// Cascading parameter from PhotoSwipeOverlayControlGroup
    /// </summary>
    [CascadingParameter] public PhotoSwipeOverlayControlGroup? ControlGroup { get; set; }

    private int _spacingIndex = 0;
    private bool _isInGroup => ControlGroup != null;

    protected override void OnInitialized()
    {
        if (_isInGroup)
        {
            _spacingIndex = ControlGroup!.RegisterControl();
        }
    }

    private string GetPositionClass()
    {
        return Position switch
        {
            OverlayPosition.TopLeft => "position-top-left",
            OverlayPosition.TopRight => "position-top-right",
            OverlayPosition.TopCenter => "position-top-center",
            OverlayPosition.BottomLeft => "position-bottom-left",
            OverlayPosition.BottomRight => "position-bottom-right",
            OverlayPosition.BottomCenter => "position-bottom-center",
            OverlayPosition.CenterLeft => "position-center-left",
            OverlayPosition.CenterRight => "position-center-right",
            OverlayPosition.Center => "position-center",
            OverlayPosition.Custom => "position-custom",
            _ => "position-top-right"
        };
    }

    private string? GetPositionStyle()
    {
        // When inside a control group, let the group handle positioning
        if (_isInGroup)
        {
            return !string.IsNullOrEmpty(CustomPosition) ? CustomPosition : null;
        }

        // Standalone positioning (when not in a group)
        if (!string.IsNullOrEmpty(CustomPosition))
        {
            return CustomPosition;
        }

        // Simple positioning with optional custom offset
        if (!string.IsNullOrEmpty(Offset))
        {
            return Position switch
            {
                OverlayPosition.TopLeft => $"top: {Offset}; left: {Offset};",
                OverlayPosition.TopRight => $"top: {Offset}; right: {Offset};",
                OverlayPosition.TopCenter => $"top: {Offset}; left: 50%; transform: translateX(-50%);",
                OverlayPosition.BottomLeft => $"bottom: {Offset}; left: {Offset};",
                OverlayPosition.BottomRight => $"bottom: {Offset}; right: {Offset};",
                OverlayPosition.BottomCenter => $"bottom: {Offset}; left: 50%; transform: translateX(-50%);",
                OverlayPosition.CenterLeft => $"top: 50%; left: {Offset}; transform: translateY(-50%);",
                OverlayPosition.CenterRight => $"top: 50%; right: {Offset}; transform: translateY(-50%);",
                OverlayPosition.Center => $"top: 50%; left: 50%; transform: translate(-50%, -50%);",
                _ => null
            };
        }

        // Default positioning uses CSS classes (no inline styles needed)
        return null;
    }


    private int GetResponsiveButtonSize()
    {
        // When in a group, use the group's button size
        if (_isInGroup && ControlGroup!.ButtonSize.HasValue)
        {
            return ControlGroup.ButtonSize.Value;
        }

        // Use control's custom button size if provided
        if (ButtonSize.HasValue) return ButtonSize.Value;

        // Default responsive sizing based on CSS variables
        // 40px on desktop, 44px on mobile (matches CSS media query at 768px)
        // Since we can't detect screen size in Blazor Server, we use the larger mobile size
        // to ensure adequate spacing for the most constrained scenario
        return 44;
    }

    private string? GetButtonSizeStyle()
    {
        var effectiveSize = GetResponsiveButtonSize();

        // Always apply size when we have an explicit value (either from group or control)
        if ((_isInGroup && ControlGroup!.ButtonSize.HasValue) || ButtonSize.HasValue)
        {
            return $"width: {effectiveSize}px; height: {effectiveSize}px;";
        }

        return null;
    }
}