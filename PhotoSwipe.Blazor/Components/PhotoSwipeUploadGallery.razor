@using PhotoSwipe.Blazor.Models
@using PhotoSwipe.Blazor.Services
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Logging
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject ILogger<PhotoSwipeUploadGallery> Logger

<div class="photoswipe-upload-gallery @CssClass">
    
    <!-- Upload Section -->
    @if (!ReadOnly && AllowUploads)
    {
        <div class="upload-section">
            <div class="upload-header">
                <h3 class="upload-title">üì∏ Upload Images</h3>
                <div class="upload-info">
                    <span class="file-types">üìÑ Supported: @string.Join(", ", GetSupportedTypes())</span>
                    <span class="size-limit">üìè Max: @FormatFileSize(MaxFileSize) per file</span>
                </div>
            </div>

            <div class="upload-area @(_isDragOver ? "drag-over" : "")"
                 @ondragenter="OnDragEnter"
                 @ondragleave="OnDragLeave"
                 @ondragover="OnDragOver"
                 @ondragover:preventDefault="true"
                 @ondrop="OnDrop"
                 @ondrop:preventDefault="true">

                <!-- Use a label that wraps the InputFile for native browser behavior -->
                <label class="upload-label" style="cursor: pointer; display: block; width: 100%; height: 100%;">
                    <InputFile @ref="inputFileRef"
                              OnChange="OnFilesSelected"
                              multiple="@AllowMultipleFiles"
                              accept="@ImageProcessingService.GetFileAcceptString()"
                              style="display: none;" />

                    <div class="upload-prompt">
                        <div class="upload-icon">üìÅ</div>
                        <div class="upload-text">
                            <p class="primary-text">Drop @(AllowMultipleFiles ? "images" : "an image") here or click to select</p>
                            <p class="secondary-text">@(AllowMultipleFiles ? "You can select multiple files at once" : "Select a single image file")</p>
                        </div>
                    </div>
                </label>
            </div>

            @if (_isProcessing)
            {
                <div class="processing-status">
                    <div class="loading-spinner"></div>
                    <span>Processing @_processingCount of @_totalFiles files...</span>
                </div>
            }

            <!-- Upload Controls -->
            @if (_uploadedItems.Any() && !_isProcessing)
            {
                <div class="upload-controls">
                    <div class="upload-stats">
                        @_uploadedItems.Count file(s) ready to add
                    </div>
                    <div class="upload-buttons">
                        <label class="upload-mode">
                            <input type="radio" name="uploadMode" checked="@(UploadMode == PhotoSwipeUploadMode.Add)" @onchange="@(() => UploadMode = PhotoSwipeUploadMode.Add)" />
                            Add to Gallery
                        </label>
                        <label class="upload-mode">
                            <input type="radio" name="uploadMode" checked="@(UploadMode == PhotoSwipeUploadMode.Replace)" @onchange="@(() => UploadMode = PhotoSwipeUploadMode.Replace)" />
                            Replace Gallery
                        </label>
                        <button class="btn-confirm" @onclick="ConfirmUpload" disabled="@_isProcessing">
                            ‚úÖ Confirm Upload
                        </button>
                        <button class="btn-cancel" @onclick="ClearUpload">
                            ‚ùå Cancel
                        </button>
                    </div>
                </div>
            }

            <!-- Error Messages -->
            @if (_errorMessages.Any())
            {
                <div class="error-messages">
                    @foreach (var error in _errorMessages)
                    {
                        <div class="error-message">‚ö†Ô∏è @error</div>
                    }
                    <button class="btn-clear-errors" @onclick="ClearErrors">Clear Errors</button>
                </div>
            }

            <!-- Upload Preview -->
            @if (_uploadedItems.Any() && !_isProcessing)
            {
                <div class="upload-preview">
                    <h4>Preview (@_uploadedItems.Count files):</h4>
                    <div class="preview-grid">
                        @foreach (var item in _uploadedItems)
                        {
                            <div class="preview-item">
                                <img src="@item.ThumbnailUrl" alt="@item.Alt" class="preview-thumbnail" />
                                <div class="preview-info">
                                    <span class="preview-name">@item.Title</span>
                                    <span class="preview-size">@item.Width√ó@item.Height</span>
                                </div>
                                <button class="btn-remove" @onclick="() => RemoveUploadedItem(item)">√ó</button>
                            </div>
                        }
                    </div>
                </div>
            }
        </div>
    }

    <!-- Selection Controls -->
    @if (_combinedItems.Any() && EnableSelection)
    {
        <div class="selection-controls">
            @if (AllowMultiSelect)
            {
                <div class="mass-selection">
                    <button class="btn-select-all" @onclick="SelectAll">Select All</button>
                    <button class="btn-deselect-all" @onclick="DeselectAll">Deselect All</button>
                    @if (_selectedItems.Any())
                    {
                        <button class="btn-delete-selected" @onclick="() => ShowDeleteConfirmation(_selectedItems.ToList())">Delete Selected (@_selectedItems.Count)</button>
                    }
                </div>
            }
        </div>
    }

    <!-- Gallery using PhotoSwipeGallery component -->
    <PhotoSwipeGallery Id="@_galleryElementId" 
                       Items="@_combinedItems" 
                       Options="@Options" 
                       CssClass="@($"upload-gallery-display {CssClass}")"
                       OnOpen="OnOpen" 
                       OnClose="OnClose" 
                       OnChange="OnChange">
        
        <ItemTemplate Context="item">
            <div class="gallery-item-wrapper">
                <!-- Selection Overlay -->
                @if (EnableSelection)
                {
                    <div class="selection-overlay">
                        @if (AllowMultiSelect)
                        {
                            <input type="checkbox" 
                                   class="selection-checkbox"
                                   checked="@_selectedItems.Contains(item)"
                                   @onchange="@(e => ToggleSelection(item, (bool)e.Value!))" />
                        }
                        else
                        {
                            <input type="radio"
                                   class="selection-radio"
                                   name="single-select"
                                   checked="@(SelectedItem == item)"
                                   @onchange="@(e => SelectSingle(item, !string.IsNullOrEmpty(e.Value?.ToString())))" />
                        }
                    </div>
                }
                
                <!-- Delete Overlay -->
                <div class="delete-overlay">
                    <button class="btn-delete-item" 
                            @onclick="@(() => ShowDeleteConfirmation(new List<PhotoSwipeItem> { item }))"
                            title="Delete this image">
                        √ó
                    </button>
                </div>
                
                <!-- Item Content -->
                @if (ItemTemplate != null)
                {
                    @ItemTemplate(item)
                }
                else
                {
                    <img src="@item.ThumbnailUrl" alt="@item.Alt" class="gallery-image" />
                }
            </div>
        </ItemTemplate>
        
    </PhotoSwipeGallery>
    
    <!-- Empty State -->
    @if (!_combinedItems.Any())
    {
        <div class="empty-gallery">
            <p>No images in gallery.</p>
            @if (!ReadOnly && AllowUploads)
            {
                <p>Upload some images to get started!</p>
            }
        </div>
    }
    
    <!-- Delete Confirmation Modal -->
    @if (_showDeleteConfirmation)
    {
        <div class="delete-confirmation-modal">
            <div class="modal-content">
                <h3>Confirm Delete</h3>
                <p>Are you sure you want to delete @(_itemsToDelete.Count == 1 ? "this image" : $"these {_itemsToDelete.Count} images")? This action cannot be undone.</p>
                <div class="modal-buttons">
                    <button class="btn-confirm-delete" @onclick="ConfirmDelete">Delete</button>
                    <button class="btn-cancel-delete" @onclick="CancelDelete">Cancel</button>
                </div>
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public string? Id { get; set; }
    [Parameter] public string? CssClass { get; set; }
    [Parameter] public IEnumerable<PhotoSwipeItem>? Items { get; set; }
    [Parameter] public PhotoSwipeOptions? Options { get; set; }
    [Parameter] public RenderFragment<PhotoSwipeItem>? ItemTemplate { get; set; }
    
    // Upload parameters
    [Parameter] public bool AllowUploads { get; set; } = true;
    [Parameter] public bool ReadOnly { get; set; } = false;
    [Parameter] public PhotoSwipeUploadMode UploadMode { get; set; } = PhotoSwipeUploadMode.Add;
    [Parameter] public long MaxFileSize { get; set; } = 10 * 1024 * 1024; // 10MB
    [Parameter] public int MaxFiles { get; set; } = 20;
    [Parameter] public bool AllowMultipleFiles { get; set; } = true;
    
    // Selection parameters
    [Parameter] public bool AllowMultiSelect { get; set; } = true;
    [Parameter] public PhotoSwipeItem? SelectedItem { get; set; }
    [Parameter] public IEnumerable<PhotoSwipeItem>? SelectedItems { get; set; }
    [Parameter] public bool EnableSelection { get; set; } = false;
    
    // Events
    [Parameter] public EventCallback<PhotoSwipeEventArgs> OnOpen { get; set; }
    [Parameter] public EventCallback<PhotoSwipeEventArgs> OnClose { get; set; }
    [Parameter] public EventCallback<PhotoSwipeEventArgs> OnChange { get; set; }
    [Parameter] public EventCallback<PhotoSwipeItem> SelectedItemChanged { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> SelectedItemsChanged { get; set; }
    [Parameter] public EventCallback<PhotoSwipeItem> OnItemDeleted { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsDeleted { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsUploaded { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsChanged { get; set; }

    private ImageProcessingService? _imageProcessor;
    private InputFile? inputFileRef;
    
    private readonly List<PhotoSwipeItem> _originalItems = [];
    private readonly List<PhotoSwipeItem> _confirmedItems = [];
    private readonly List<PhotoSwipeItem> _uploadedItems = [];
    private readonly List<PhotoSwipeItem> _selectedItems = [];
    private readonly List<string> _errorMessages = [];
    
    private IEnumerable<PhotoSwipeItem> _combinedItems = [];
    private List<PhotoSwipeItem> _itemsToDelete = [];
    private bool _showDeleteConfirmation = false;
    
    private bool _isProcessing = false;
    private bool _isDragOver = false;
    private int _processingCount = 0;
    private int _totalFiles = 0;
    
    // Store the gallery ElementId for consistent PhotoSwipe interop
    private string? _galleryElementId;

    protected override void OnInitialized()
    {
        _imageProcessor = new ImageProcessingService(JS);
        // Generate a consistent ElementId for the PhotoSwipeGallery
        // This must be set before PhotoSwipeGallery.OnInitialized runs
        _galleryElementId = Id ?? $"photoswipe-upload-{Guid.NewGuid():N}";
        UpdateCombinedItems();
    }

    protected override void OnParametersSet()
    {
        // Store original items on first load or when Items changes externally
        // We need to detect if Items has changed from what we expect (original + confirmed)
        var expectedCombined = _originalItems.Concat(_confirmedItems).ToList();
        var currentItems = (Items ?? Enumerable.Empty<PhotoSwipeItem>()).ToList();

        // If Items doesn't match our expected combined items, it means Items was updated externally
        // or this is the first load, so we should update _originalItems
        if (!_originalItems.Any() || !currentItems.SequenceEqual(expectedCombined))
        {
            _originalItems.Clear();
            _originalItems.AddRange(currentItems.Except(_confirmedItems));
        }

        // Update selected items when parameters change
        if (SelectedItems != null)
        {
            _selectedItems.Clear();
            _selectedItems.AddRange(SelectedItems);
        }

        UpdateCombinedItems();
    }

    private void UpdateCombinedItems()
    {
        _combinedItems = UploadMode switch
        {
            PhotoSwipeUploadMode.Add => _originalItems.Concat(_confirmedItems),
            PhotoSwipeUploadMode.Replace => _confirmedItems.Any() ? _confirmedItems : _originalItems,
            _ => _originalItems
        };
    }

    private async Task OnFilesSelected(InputFileChangeEventArgs e)
    {
        Logger.LogInformation("OnFilesSelected called with {FileCount} files", e.FileCount);

        IEnumerable<IBrowserFile> files;
        if (AllowMultipleFiles)
        {
            files = e.GetMultipleFiles(MaxFiles);
        }
        else
        {
            // For single file mode, only take the first file
            files = e.FileCount > 0 ? new[] { e.File } : Enumerable.Empty<IBrowserFile>();
        }

        await ProcessFiles(files);
    }

    private async Task ProcessFiles(IEnumerable<IBrowserFile> files)
    {
        _isProcessing = true;
        _processingCount = 0;
        _totalFiles = files.Count();
        _errorMessages.Clear();
        
        try
        {
            Logger.LogInformation("Processing {FileCount} uploaded files", _totalFiles);

            var results = new List<PhotoSwipeItem>();
            
            foreach (var file in files)
            {
                _processingCount++;
                StateHasChanged(); // Update progress
                
                try
                {
                    if (!_imageProcessor!.IsValidFileType(file))
                    {
                        _errorMessages.Add($"{file.Name}: Unsupported file type. Supported: {string.Join(", ", GetSupportedTypes())}");
                        continue;
                    }

                    if (!_imageProcessor.IsValidFileSize(file, MaxFileSize))
                    {
                        _errorMessages.Add($"{file.Name}: File too large ({ImageProcessingService.FormatFileSize(file.Size)}). Max: {FormatFileSize(MaxFileSize)}");
                        continue;
                    }

                    var photoSwipeItem = await _imageProcessor.ProcessImageFileAsync(file, MaxFileSize);
                    results.Add(photoSwipeItem);
                    Logger.LogDebug("Processed file: {FileName}", file.Name);
                }
                catch (Exception ex)
                {
                    _errorMessages.Add($"{file.Name}: {ex.Message}");
                    Logger.LogError(ex, "Error processing file: {FileName}", file.Name);
                }
            }

            _uploadedItems.AddRange(results);
            Logger.LogInformation("Successfully processed {SuccessCount}/{TotalCount} files, _uploadedItems now has {UploadedCount} items", results.Count, _totalFiles, _uploadedItems.Count);
        }
        finally
        {
            _isProcessing = false;
            StateHasChanged();
        }
    }

    private async Task ConfirmUpload()
    {
        if (!_uploadedItems.Any()) return;

        if (UploadMode == PhotoSwipeUploadMode.Replace)
        {
            // Clear previous confirmed items for replace mode
            _confirmedItems.Clear();
        }

        _confirmedItems.AddRange(_uploadedItems);
        var uploadedItems = _uploadedItems.ToList();
        _uploadedItems.Clear();

        UpdateCombinedItems();

        if (OnItemsUploaded.HasDelegate)
        {
            await OnItemsUploaded.InvokeAsync(uploadedItems);
        }

        if (OnItemsChanged.HasDelegate)
        {
            await OnItemsChanged.InvokeAsync(_combinedItems);
        }

        StateHasChanged();
        Logger.LogInformation("Confirmed upload of {ItemCount} items", uploadedItems.Count);
    }

    private void ClearUpload()
    {
        _uploadedItems.Clear();
        _errorMessages.Clear();
        StateHasChanged();
    }

    private void RemoveUploadedItem(PhotoSwipeItem item)
    {
        _uploadedItems.Remove(item);
        StateHasChanged();
    }

    private void ClearErrors()
    {
        _errorMessages.Clear();
        StateHasChanged();
    }

    // Selection methods
    private async Task ToggleSelection(PhotoSwipeItem item, bool isSelected)
    {
        if (isSelected)
        {
            if (!_selectedItems.Contains(item))
            {
                _selectedItems.Add(item);
            }
        }
        else
        {
            _selectedItems.Remove(item);
        }

        if (SelectedItemsChanged.HasDelegate)
        {
            await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
        }

        StateHasChanged();
    }

    private async Task SelectSingle(PhotoSwipeItem item, bool isSelected)
    {
        if (isSelected)
        {
            _selectedItems.Clear();
            _selectedItems.Add(item);
            
            if (SelectedItemChanged.HasDelegate)
            {
                await SelectedItemChanged.InvokeAsync(item);
            }
        }
        else if (_selectedItems.Contains(item))
        {
            _selectedItems.Remove(item);
            
            if (SelectedItemChanged.HasDelegate)
            {
                await SelectedItemChanged.InvokeAsync(null);
            }
        }

        StateHasChanged();
    }

    private async Task SelectAll()
    {
        _selectedItems.Clear();
        _selectedItems.AddRange(_combinedItems);
        
        if (SelectedItemsChanged.HasDelegate)
        {
            await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
        }
        
        StateHasChanged();
    }

    private async Task DeselectAll()
    {
        _selectedItems.Clear();
        
        if (SelectedItemsChanged.HasDelegate)
        {
            await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
        }
        
        StateHasChanged();
    }
    
    // Delete methods
    private void ShowDeleteConfirmation(List<PhotoSwipeItem> items)
    {
        _itemsToDelete = items;
        _showDeleteConfirmation = true;
        StateHasChanged();
    }
    
    private async Task ConfirmDelete()
    {
        try
        {
            // Remove from confirmed items
            foreach (var item in _itemsToDelete)
            {
                _confirmedItems.Remove(item);
                _selectedItems.Remove(item);
            }
            
            UpdateCombinedItems();
            
            // Notify parent components
            if (_itemsToDelete.Count == 1 && OnItemDeleted.HasDelegate)
            {
                await OnItemDeleted.InvokeAsync(_itemsToDelete[0]);
            }
            else if (_itemsToDelete.Count > 1 && OnItemsDeleted.HasDelegate)
            {
                await OnItemsDeleted.InvokeAsync(_itemsToDelete);
            }
            
            // Update OnItemsChanged
            if (OnItemsChanged.HasDelegate)
            {
                await OnItemsChanged.InvokeAsync(_combinedItems);
            }
            
            Logger.LogInformation("Deleted {ItemCount} items", _itemsToDelete.Count);
            
            // Update selection events
            if (AllowMultiSelect && SelectedItemsChanged.HasDelegate)
            {
                await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
            }
            
            if (!AllowMultiSelect && SelectedItemChanged.HasDelegate && _selectedItems.Count == 0)
            {
                await SelectedItemChanged.InvokeAsync(null);
            }
            
        }
        finally
        {
            _showDeleteConfirmation = false;
            _itemsToDelete.Clear();
            StateHasChanged();
        }
    }
    
    private void CancelDelete()
    {
        _showDeleteConfirmation = false;
        _itemsToDelete.Clear();
        StateHasChanged();
    }

    // Event handlers
    private void OnDragEnter() => _isDragOver = true;
    private void OnDragLeave() => _isDragOver = false;
    private void OnDragOver(DragEventArgs e) => e.DataTransfer.DropEffect = "copy";
    
    private void OnDrop(DragEventArgs e)
    {
        _isDragOver = false;
        
        // Note: DataTransfer.Files from DragEventArgs are filenames, not IBrowserFile
        // Real drag & drop file processing needs to be handled differently
        // For now, we'll just reset the drag state
        StateHasChanged();
    }
    // Helper methods
    private static string[] GetSupportedTypes() => ImageProcessingService.GetSupportedTypes();
    private static string FormatFileSize(long bytes) => ImageProcessingService.FormatFileSize(bytes);

    public async ValueTask DisposeAsync()
    {
        // Component cleanup if needed
        await Task.CompletedTask;
    }
}