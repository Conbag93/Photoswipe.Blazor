@using PhotoSwipe.Blazor.Models
@using PhotoSwipe.Blazor.Services
@using PhotoSwipe.Blazor.Extensions
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.Logging
@implements IAsyncDisposable
@inject IJSRuntime JS
@inject ILogger<PhotoSwipeUploadGallery> Logger
@inject ILogger<PhotoSwipeInterop> InteropLogger

<div class="photoswipe-upload-gallery @CssClass">

    <!-- Upload Area - Above Position -->
    @if (AllowAdd && UploadPosition == PhotoSwipeUploadPosition.Above)
    {
        <PhotoSwipeUploadArea Id="@($"{_galleryElementId}-upload-above")"
                            UploadMode="@UploadMode"
                            MaxFileSize="@MaxFileSize"
                            MaxFiles="@MaxFiles"
                            AllowMultipleFiles="@AllowMultipleFiles"
                            OnItemsUploaded="@OnUploadAreaItemsUploaded"
                            OnUploadModeChanged="@OnUploadAreaModeChanged"
                            OnUploadError="@OnUploadAreaError" />
    }

    <!-- Selection Controls -->
    @if (_displayItems.Any() && EnableSelection)
    {
        <div class="selection-controls">
            @if (AllowMultiSelect)
            {
                <div class="mass-selection">
                    <button class="btn-select-all" @onclick="SelectAll">Select All</button>
                    <button class="btn-deselect-all" @onclick="DeselectAll">Deselect All</button>
                    @if (AllowDelete && _selectedItems.Any())
                    {
                        <button class="btn-delete-selected" @onclick="() => ShowDeleteConfirmation(_selectedItems.ToList())">Delete Selected (@_selectedItems.Count)</button>
                    }
                </div>
            }
        </div>
    }

    <!-- Gallery with custom rendering for placeholders -->
    <div id="@_galleryElementId" class="photoswipe-gallery upload-gallery-display @CssClass">
        @foreach (var item in _displayItems)
        {
            @if (item.IsPlaceholder())
            {
                <!-- Render placeholder as a div with data-pswp-prevent-gallery to prevent PhotoSwipe from opening -->
                <div class="photoswipe-item placeholder-item"
                     data-pswp-prevent-gallery="true"
                     data-placeholder-type="@item.GetPlaceholderType()"
                     data-placeholder-id="@item.GetPlaceholderId()">
                    <div class="gallery-item-wrapper">
                        <!-- Upload Placeholder UI -->
                        <div class="upload-placeholder-content" @onclick="OnUploadPlaceholderClick">
                            <div class="upload-placeholder-background">
                                <img src="@item.ThumbnailUrl" alt="@item.Alt" class="upload-placeholder-image" />
                                @if (!string.IsNullOrEmpty(item.Title))
                                {
                                    <div class="upload-placeholder-text">@item.Title</div>
                                }
                            </div>
                        </div>
                    </div>
                </div>
            }
            else
            {
                <!-- Regular gallery item wrapped in anchor tag for PhotoSwipe -->
                <a href="@item.Src"
                   data-pswp-width="@item.Width"
                   data-pswp-height="@item.Height"
                   data-caption="@item.Caption"
                   data-pswp-srcset="@item.SrcSet"
                   data-enhance-nav="false"
                   class="photoswipe-item">
                    <div class="gallery-item-wrapper">
                        <!-- Selection Overlay with configurable position -->
                        @if (EnableSelection)
                        {
                            <PhotoSwipeOverlayControl Position="@SelectionPosition"
                                                    ControlType="selection"
                                                    PreventGallery="true">
                                @if (AllowMultiSelect)
                                {
                                    <input type="checkbox"
                                           class="selection-checkbox"
                                           checked="@_selectedItems.Contains(item)"
                                           @onchange="@(e => ToggleSelection(item, (bool)e.Value!))" />
                                }
                                else
                                {
                                    <input type="radio"
                                           class="selection-radio"
                                           name="single-select-@_galleryElementId"
                                           checked="@(SelectedItem == item)"
                                           @onchange="@(e => SelectSingle(item, !string.IsNullOrEmpty(e.Value?.ToString())))" />
                                }
                            </PhotoSwipeOverlayControl>
                        }

                        <!-- Delete Overlay using new PhotoSwipeOverlayControl -->
                        @if (AllowDelete)
                        {
                            <PhotoSwipeOverlayControl Position="PhotoSwipeOverlayControl.OverlayPosition.BottomRight"
                                                    ControlType="delete"
                                                    Icon="×"
                                                    Title="Delete this image"
                                                    AriaLabel="Delete image"
                                                    CssClass="delete-overlay-control"
                                                    ButtonCssClass="size-delete btn-delete-item"
                                                    OnClick="@(() => ShowDeleteConfirmation(new List<PhotoSwipeItem> { item }))" />
                        }

                        <!-- Reordering Controls -->
                        @if (AllowReorder && ShowIndexLabels)
                        {
                            <PhotoSwipeOverlayControl Position="PhotoSwipeOverlayControl.OverlayPosition.TopLeft"
                                                    ControlType="index"
                                                    Icon="@GetIndexLabel(item)"
                                                    ButtonCssClass="index-label"
                                                    Title="@GetIndexTooltip(item)"
                                                    Disabled="true"
                                                    SpacingIndex="0"
                                                    Direction="PhotoSwipeOverlayControl.GrowDirection.Right"
                                                    ControlGap="4" />
                        }

                        @if (AllowReorder)
                        {
                            <!-- Up Arrow (Top-Right) -->
                            <PhotoSwipeOverlayControl Position="PhotoSwipeOverlayControl.OverlayPosition.TopRight"
                                                    ControlType="reorder-up"
                                                    Icon="@GetUpArrowSvg()"
                                                    ButtonCssClass="@GetUpArrowButtonClass(item)"
                                                    Title="@GetUpArrowTooltip(item)"
                                                    OnClick="@(() => MoveItemUp(item))"
                                                    Disabled="@IsUpArrowDisabled(item)"
                                                    SpacingIndex="0"
                                                    Direction="PhotoSwipeOverlayControl.GrowDirection.Left"
                                                    ControlGap="4" />

                            <!-- Down Arrow (Bottom-Right) -->
                            <PhotoSwipeOverlayControl Position="PhotoSwipeOverlayControl.OverlayPosition.BottomRight"
                                                    ControlType="reorder-down"
                                                    Icon="@GetDownArrowSvg()"
                                                    ButtonCssClass="@GetDownArrowButtonClass(item)"
                                                    Title="@GetDownArrowTooltip(item)"
                                                    OnClick="@(() => MoveItemDown(item))"
                                                    Disabled="@IsDownArrowDisabled(item)"
                                                    SpacingIndex="@(AllowDelete ? 1 : 0)"
                                                    Direction="PhotoSwipeOverlayControl.GrowDirection.Left"
                                                    ControlGap="4" />
                        }

                        <!-- Custom Overlay Controls (for user extensibility) -->
                        @if (CustomOverlayControls != null)
                        {
                            @CustomOverlayControls(item)
                        }

                        <!-- Item Content -->
                        @if (ItemTemplate != null)
                        {
                            @ItemTemplate(item)
                        }
                        else
                        {
                            <img src="@item.ThumbnailUrl" alt="@item.Alt" class="gallery-image" />
                        }
                    </div>
                </a>
            }
        }
    </div>

    <!-- Upload Area - Below Position -->
    @if (AllowAdd && UploadPosition == PhotoSwipeUploadPosition.Below)
    {
        <PhotoSwipeUploadArea Id="@($"{_galleryElementId}-upload-below")"
                            UploadMode="@UploadMode"
                            MaxFileSize="@MaxFileSize"
                            MaxFiles="@MaxFiles"
                            AllowMultipleFiles="@AllowMultipleFiles"
                            OnItemsUploaded="@OnUploadAreaItemsUploaded"
                            OnUploadModeChanged="@OnUploadAreaModeChanged"
                            OnUploadError="@OnUploadAreaError" />
    }

    <!-- Empty State -->
    @if (!_displayItems.Any())
    {
        <div class="empty-gallery">
            <p>No images in gallery.</p>
            @if (AllowAdd)
            {
                <p>Upload some images to get started!</p>
            }
        </div>
    }
    
    <!-- Delete Confirmation Modal -->
    @if (AllowDelete && _showDeleteConfirmation)
    {
        <div class="delete-confirmation-modal">
            <div class="modal-content">
                <h3>Confirm Delete</h3>
                <p>Are you sure you want to delete @(_itemsToDelete.Count == 1 ? "this image" : $"these {_itemsToDelete.Count} images")? This action cannot be undone.</p>
                <div class="modal-buttons">
                    <button class="btn-confirm-delete" @onclick="ConfirmDelete">Delete</button>
                    <button class="btn-cancel-delete" @onclick="CancelDelete">Cancel</button>
                </div>
            </div>
        </div>
    }

    <!-- Contained Upload Modal -->
    @if (UploadPosition == PhotoSwipeUploadPosition.Contained && _showContainedUpload)
    {
        <div class="contained-upload-modal">
            <div class="modal-overlay" @onclick="CloseContainedUpload"></div>
            <div class="modal-content contained-upload-content">
                <div class="modal-header">
                    <h3>Upload Images</h3>
                    <button class="btn-close-modal" @onclick="CloseContainedUpload">×</button>
                </div>
                <PhotoSwipeUploadArea Id="@($"{_galleryElementId}-upload-contained")"
                                    UploadMode="@UploadMode"
                                    MaxFileSize="@MaxFileSize"
                                    MaxFiles="@MaxFiles"
                                    AllowMultipleFiles="@AllowMultipleFiles"
                                    OnItemsUploaded="@OnContainedUploadCompleted"
                                    OnUploadModeChanged="@OnUploadAreaModeChanged"
                                    OnUploadError="@OnUploadAreaError" />
            </div>
        </div>
    }
</div>

@code {
    [Parameter] public string? Id { get; set; }
    [Parameter] public string? CssClass { get; set; }
    [Parameter] public IEnumerable<PhotoSwipeItem>? Items { get; set; }
    [Parameter] public PhotoSwipeOptions? Options { get; set; }
    [Parameter] public RenderFragment<PhotoSwipeItem>? ItemTemplate { get; set; }
    [Parameter] public RenderFragment<PhotoSwipeItem>? CustomOverlayControls { get; set; }
    
    // Upload parameters
    [Parameter] public bool AllowAdd { get; set; } = true;
    [Parameter] public bool AllowDelete { get; set; } = false;
    [Parameter] public PhotoSwipeUploadMode UploadMode { get; set; } = PhotoSwipeUploadMode.Add;
    [Parameter] public PhotoSwipeUploadPosition UploadPosition { get; set; } = PhotoSwipeUploadPosition.Above;
    [Parameter] public PhotoSwipeContainedUploadPosition ContainedUploadPosition { get; set; } = PhotoSwipeContainedUploadPosition.Last;
    [Parameter] public string UploadPlaceholderText { get; set; } = "Add Files";
    [Parameter] public long MaxFileSize { get; set; } = 10 * 1024 * 1024; // 10MB
    [Parameter] public int MaxFiles { get; set; } = 20;
    [Parameter] public bool AllowMultipleFiles { get; set; } = true;
    
    // Selection parameters
    [Parameter] public bool AllowMultiSelect { get; set; } = true;
    [Parameter] public PhotoSwipeItem? SelectedItem { get; set; }
    [Parameter] public IEnumerable<PhotoSwipeItem>? SelectedItems { get; set; }
    [Parameter] public bool EnableSelection { get; set; } = false;
    [Parameter] public PhotoSwipeOverlayControl.OverlayPosition SelectionPosition { get; set; } = PhotoSwipeOverlayControl.OverlayPosition.TopLeft;

    // Reordering parameters
    [Parameter] public bool AllowReorder { get; set; } = false;
    [Parameter] public bool ShowIndexLabels { get; set; } = true;
    
    // Events
    [Parameter] public EventCallback<PhotoSwipeEventArgs> OnOpen { get; set; }
    [Parameter] public EventCallback<PhotoSwipeEventArgs> OnClose { get; set; }
    [Parameter] public EventCallback<PhotoSwipeEventArgs> OnChange { get; set; }
    [Parameter] public EventCallback<PhotoSwipeItem> SelectedItemChanged { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> SelectedItemsChanged { get; set; }
    [Parameter] public EventCallback<PhotoSwipeItem> OnItemDeleted { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsDeleted { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsUploaded { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsChanged { get; set; }
    [Parameter] public EventCallback<IEnumerable<PhotoSwipeItem>> OnItemsReordered { get; set; }

    private readonly List<PhotoSwipeItem> _originalItems = [];
    private readonly List<PhotoSwipeItem> _confirmedItems = [];
    private readonly List<PhotoSwipeItem> _selectedItems = [];

    // Separate collections for data vs display
    private IEnumerable<PhotoSwipeItem> _dataItems = [];
    private List<PhotoSwipeItem> _displayItems = [];
    private List<PhotoSwipeItem> _itemsToDelete = [];
    private bool _showDeleteConfirmation = false;

    // Store the gallery ElementId for consistent PhotoSwipe interop
    private string? _galleryElementId;

    // PhotoSwipe interop
    private PhotoSwipeInterop? _interop;
    private string? _instanceId;
    private IEnumerable<PhotoSwipeItem>? _previousDataItems;

    // Placeholder management
    private readonly List<PhotoSwipePlaceholderInfo> _placeholders = [];
    private PhotoSwipePlaceholderInfo? _uploadPlaceholder;

    // State for contained upload modal/area
    private bool _showContainedUpload = false;

    protected override void OnInitialized()
    {
        // Generate a consistent ElementId for the gallery
        _galleryElementId = Id ?? $"photoswipe-upload-{Guid.NewGuid():N}";

        // Initialize PhotoSwipe interop
        _interop = new PhotoSwipeInterop(JS, InteropLogger);

        UpdateDisplayItems();
    }

    protected override void OnParametersSet()
    {
        // Store original items on first load or when Items changes externally
        // We need to detect if Items has changed from what we expect (original + confirmed)
        var expectedCombined = _originalItems.Concat(_confirmedItems).ToList();
        var currentItems = (Items ?? Enumerable.Empty<PhotoSwipeItem>()).ToList();

        // If Items doesn't match our expected combined items, it means Items was updated externally
        // or this is the first load, so we should update _originalItems
        if (!_originalItems.Any() || !currentItems.SequenceEqual(expectedCombined))
        {
            _originalItems.Clear();
            _originalItems.AddRange(currentItems.Except(_confirmedItems));
        }

        // Update selected items when parameters change
        if (SelectedItems != null)
        {
            _selectedItems.Clear();
            _selectedItems.AddRange(SelectedItems);
        }

        UpdateDisplayItems();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        Logger.LogDebug("🔄 OnAfterRenderAsync called for {ElementId}, firstRender: {FirstRender}, interop: {HasInterop}", _galleryElementId, firstRender, _interop != null);

        if (firstRender && _interop != null && _galleryElementId != null)
        {
            try
            {
                Logger.LogInformation("🚀 Initializing PhotoSwipe for element {ElementId}", _galleryElementId);
                _instanceId = await _interop.InitializeLightboxAsync(_galleryElementId, Options);
                Logger.LogInformation("✅ PhotoSwipe initialized with instance ID: {InstanceId}", _instanceId);

                // Add event handlers if delegates are present
                if (OnOpen.HasDelegate)
                {
                    await _interop.AddEventHandlerAsync(_instanceId, "openPswp", OnOpen);
                    Logger.LogDebug("📡 Added OnOpen event handler");
                }

                if (OnClose.HasDelegate)
                {
                    await _interop.AddEventHandlerAsync(_instanceId, "closePswp", OnClose);
                    Logger.LogDebug("📡 Added OnClose event handler");
                }

                if (OnChange.HasDelegate)
                {
                    await _interop.AddEventHandlerAsync(_instanceId, "change", OnChange);
                    Logger.LogDebug("📡 Added OnChange event handler");
                }

                _previousDataItems = _dataItems;
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "❌ Error in OnAfterRenderAsync for {ElementId}: {Error}", _galleryElementId, ex.Message);
            }
        }
        else if (!firstRender && _interop != null && _instanceId != null)
        {
            // Check if data items collection has changed
            if (HasDataItemsChanged())
            {
                try
                {
                    Logger.LogInformation("🔄 Data items collection changed, refreshing PhotoSwipe for {ElementId}", _galleryElementId);
                    await _interop.RefreshGalleryAsync(_instanceId);
                    _previousDataItems = _dataItems;
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "❌ Error refreshing PhotoSwipe for {ElementId}: {Error}", _galleryElementId, ex.Message);
                }
            }
        }
    }

    private bool HasDataItemsChanged()
    {
        if (_dataItems == null && _previousDataItems == null)
            return false;

        if (_dataItems == null || _previousDataItems == null)
            return true;

        // For dynamic collections (like Lists), compare count and sequence
        var currentItems = _dataItems.ToList();
        var previousItems = _previousDataItems.ToList();

        if (currentItems.Count != previousItems.Count)
            return true;

        // Compare item sources (basic change detection)
        return !currentItems.Select(i => i.Src).SequenceEqual(previousItems.Select(i => i.Src));
    }

    private void UpdateDisplayItems()
    {
        // Build data items collection (without placeholders)
        _dataItems = UploadMode switch
        {
            PhotoSwipeUploadMode.Add => _originalItems.Concat(_confirmedItems),
            PhotoSwipeUploadMode.Replace => _confirmedItems.Any() ? _confirmedItems : _originalItems,
            _ => _originalItems
        };

        // Update placeholders collection
        UpdatePlaceholders();

        // Build display items collection (data items + placeholders)
        _displayItems.Clear();

        var dataItemsList = _dataItems.ToList();
        var placeholderItems = _placeholders
            .Where(p => p.IsEnabled)
            .Select(p => p.ToDisplayItem())
            .ToList();

        // Add placeholders in the correct positions
        if (placeholderItems.Any())
        {
            // For now, we only support contained upload position
            // Future versions can add more sophisticated placeholder positioning
            if (ContainedUploadPosition == PhotoSwipeContainedUploadPosition.First)
            {
                _displayItems.AddRange(placeholderItems);
                _displayItems.AddRange(dataItemsList);
            }
            else // Last or default
            {
                _displayItems.AddRange(dataItemsList);
                _displayItems.AddRange(placeholderItems);
            }
        }
        else
        {
            _displayItems.AddRange(dataItemsList);
        }
    }

    /// <summary>
    /// Updates the placeholders collection based on current component state
    /// </summary>
    private void UpdatePlaceholders()
    {
        _placeholders.Clear();

        // Add upload placeholder if in contained mode and uploads are allowed
        if (UploadPosition == PhotoSwipeUploadPosition.Contained && AllowAdd)
        {
            _uploadPlaceholder = new PhotoSwipePlaceholderInfo
            {
                Type = PhotoSwipePlaceholderType.Upload,
                Position = ContainedUploadPosition,
                Text = UploadPlaceholderText,
                IsEnabled = true
            };
            _placeholders.Add(_uploadPlaceholder);
        }
        else
        {
            _uploadPlaceholder = null;
        }

        // Future placeholder types can be added here
        // Example: See More, Load More, etc.
    }

    // Event handlers for PhotoSwipeUploadArea
    private async Task OnUploadAreaItemsUploaded(IEnumerable<PhotoSwipeItem> uploadedItems)
    {
        if (UploadMode == PhotoSwipeUploadMode.Replace)
        {
            // Clear previous confirmed items for replace mode
            _confirmedItems.Clear();
        }

        _confirmedItems.AddRange(uploadedItems);
        UpdateDisplayItems();

        if (OnItemsUploaded.HasDelegate)
        {
            await OnItemsUploaded.InvokeAsync(uploadedItems);
        }

        if (OnItemsChanged.HasDelegate)
        {
            await OnItemsChanged.InvokeAsync(_dataItems);
        }

        StateHasChanged();
        Logger.LogInformation("Confirmed upload of {ItemCount} items", uploadedItems.Count());
    }

    private async Task OnUploadAreaModeChanged(PhotoSwipeUploadMode mode)
    {
        UploadMode = mode;
        UpdateDisplayItems();
        StateHasChanged();
        await Task.CompletedTask;
    }

    private async Task OnUploadAreaError(string error)
    {
        Logger.LogWarning("Upload error: {Error}", error);
        await Task.CompletedTask;
    }


    // Selection methods
    private async Task ToggleSelection(PhotoSwipeItem item, bool isSelected)
    {
        if (isSelected)
        {
            if (!_selectedItems.Contains(item))
            {
                _selectedItems.Add(item);
            }
        }
        else
        {
            _selectedItems.Remove(item);
        }

        if (SelectedItemsChanged.HasDelegate)
        {
            await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
        }

        StateHasChanged();
    }

    private async Task SelectSingle(PhotoSwipeItem item, bool isSelected)
    {
        if (isSelected)
        {
            _selectedItems.Clear();
            _selectedItems.Add(item);
            
            if (SelectedItemChanged.HasDelegate)
            {
                await SelectedItemChanged.InvokeAsync(item);
            }
        }
        else if (_selectedItems.Contains(item))
        {
            _selectedItems.Remove(item);
            
            if (SelectedItemChanged.HasDelegate)
            {
                await SelectedItemChanged.InvokeAsync(null);
            }
        }

        StateHasChanged();
    }

    private async Task SelectAll()
    {
        _selectedItems.Clear();
        // Select only data items (placeholders are never selectable)
        _selectedItems.AddRange(_dataItems);

        if (SelectedItemsChanged.HasDelegate)
        {
            await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
        }

        StateHasChanged();
    }

    private async Task DeselectAll()
    {
        _selectedItems.Clear();
        
        if (SelectedItemsChanged.HasDelegate)
        {
            await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
        }
        
        StateHasChanged();
    }
    
    // Delete methods
    private void ShowDeleteConfirmation(List<PhotoSwipeItem> items)
    {
        _itemsToDelete = items;
        _showDeleteConfirmation = true;
        StateHasChanged();
    }
    
    private async Task ConfirmDelete()
    {
        try
        {
            // Remove from both original and confirmed items
            foreach (var item in _itemsToDelete)
            {
                _originalItems.Remove(item);
                _confirmedItems.Remove(item);
                _selectedItems.Remove(item);
            }
            
            UpdateDisplayItems();
            
            // Notify parent components
            if (_itemsToDelete.Count == 1 && OnItemDeleted.HasDelegate)
            {
                await OnItemDeleted.InvokeAsync(_itemsToDelete[0]);
            }
            else if (_itemsToDelete.Count > 1 && OnItemsDeleted.HasDelegate)
            {
                await OnItemsDeleted.InvokeAsync(_itemsToDelete);
            }
            
            // Update OnItemsChanged
            if (OnItemsChanged.HasDelegate)
            {
                await OnItemsChanged.InvokeAsync(_dataItems);
            }
            
            Logger.LogInformation("Deleted {ItemCount} items", _itemsToDelete.Count);
            
            // Update selection events
            if (AllowMultiSelect && SelectedItemsChanged.HasDelegate)
            {
                await SelectedItemsChanged.InvokeAsync(_selectedItems.ToList());
            }
            
            if (!AllowMultiSelect && SelectedItemChanged.HasDelegate && _selectedItems.Count == 0)
            {
                await SelectedItemChanged.InvokeAsync(null);
            }
            
        }
        finally
        {
            _showDeleteConfirmation = false;
            _itemsToDelete.Clear();
            StateHasChanged();
        }
    }
    
    private void CancelDelete()
    {
        _showDeleteConfirmation = false;
        _itemsToDelete.Clear();
        StateHasChanged();
    }

    // Reordering methods
    private async Task MoveItemUp(PhotoSwipeItem item)
    {
        // Don't allow reordering of upload placeholders
        if (item.IsPlaceholder()) return;

        var dataItems = _dataItems.ToList();
        var currentIndex = dataItems.FindIndex(i => i.Src == item.Src);
        if (currentIndex > 0)
        {
            var targetIndex = currentIndex - 1;

            // Swap with the target item
            (dataItems[currentIndex], dataItems[targetIndex]) = (dataItems[targetIndex], dataItems[currentIndex]);

            // Update the underlying collections
            UpdateDataCollections(dataItems);
            UpdateDisplayItems();

            StateHasChanged();
            Logger.LogInformation("Image moved up: {Title} from position {OldPos} to {NewPos}",
                item.Title ?? item.Alt, currentIndex + 1, targetIndex + 1);

            if (OnItemsReordered.HasDelegate)
            {
                await OnItemsReordered.InvokeAsync(dataItems);
            }

            if (OnItemsChanged.HasDelegate)
            {
                await OnItemsChanged.InvokeAsync(dataItems);
            }
        }
    }

    private async Task MoveItemDown(PhotoSwipeItem item)
    {
        // Don't allow reordering of upload placeholders
        if (item.IsPlaceholder()) return;

        var dataItems = _dataItems.ToList();
        var currentIndex = dataItems.FindIndex(i => i.Src == item.Src);
        if (currentIndex < dataItems.Count - 1)
        {
            var targetIndex = currentIndex + 1;

            // Swap with the target item
            (dataItems[currentIndex], dataItems[targetIndex]) = (dataItems[targetIndex], dataItems[currentIndex]);

            // Update the underlying collections
            UpdateDataCollections(dataItems);
            UpdateDisplayItems();

            StateHasChanged();
            Logger.LogInformation("Image moved down: {Title} from position {OldPos} to {NewPos}",
                item.Title ?? item.Alt, currentIndex + 1, targetIndex + 1);

            if (OnItemsReordered.HasDelegate)
            {
                await OnItemsReordered.InvokeAsync(dataItems);
            }

            if (OnItemsChanged.HasDelegate)
            {
                await OnItemsChanged.InvokeAsync(dataItems);
            }
        }
    }

    private void UpdateDataCollections(List<PhotoSwipeItem> reorderedItems)
    {
        // Filter out any placeholders that might have been included
        var dataOnlyItems = reorderedItems.Where(item => !item.IsPlaceholder()).ToList();

        if (UploadMode == PhotoSwipeUploadMode.Replace && _confirmedItems.Any())
        {
            // In replace mode with confirmed items, update confirmed items
            _confirmedItems.Clear();
            _confirmedItems.AddRange(dataOnlyItems);
        }
        else
        {
            // Put all reordered items in _originalItems and clear _confirmedItems
            _originalItems.Clear();
            _confirmedItems.Clear();

            _originalItems.AddRange(dataOnlyItems);
        }
    }

    // Reordering helper methods
    private string GetIndexLabel(PhotoSwipeItem item)
    {
        var dataItems = _dataItems.ToList();
        var currentIndex = dataItems.FindIndex(i => i.Src == item.Src);
        return $"{currentIndex + 1}/{dataItems.Count}";
    }

    private string GetIndexTooltip(PhotoSwipeItem item)
    {
        var dataItems = _dataItems.ToList();
        var currentIndex = dataItems.FindIndex(i => i.Src == item.Src);
        return $"Image {currentIndex + 1} of {dataItems.Count}";
    }

    private bool IsUpArrowDisabled(PhotoSwipeItem item)
    {
        var dataItems = _dataItems.ToList();
        var currentIndex = dataItems.FindIndex(i => i.Src == item.Src);
        return currentIndex <= 0; // Disabled if first item
    }

    private bool IsDownArrowDisabled(PhotoSwipeItem item)
    {
        var dataItems = _dataItems.ToList();
        var currentIndex = dataItems.FindIndex(i => i.Src == item.Src);
        return currentIndex >= dataItems.Count - 1; // Disabled if last item
    }

    private string GetUpArrowButtonClass(PhotoSwipeItem item)
    {
        return $"reorder-button up-arrow {(IsUpArrowDisabled(item) ? "disabled" : "")}";
    }

    private string GetDownArrowButtonClass(PhotoSwipeItem item)
    {
        return $"reorder-button down-arrow {(IsDownArrowDisabled(item) ? "disabled" : "")}";
    }

    private string GetUpArrowTooltip(PhotoSwipeItem item)
    {
        return IsUpArrowDisabled(item) ? "Already first image" : "Move image up";
    }

    private string GetDownArrowTooltip(PhotoSwipeItem item)
    {
        return IsDownArrowDisabled(item) ? "Already last image" : "Move image down";
    }

    private string GetUpArrowSvg()
    {
        return @"<svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 640 640"">
                   <path d=""M342.6 81.4C330.1 68.9 309.8 68.9 297.3 81.4L137.3 241.4C124.8 253.9 124.8 274.2 137.3 286.7C149.8 299.2 170.1 299.2 182.6 286.7L288 181.3L288 552C288 569.7 302.3 584 320 584C337.7 584 352 569.7 352 552L352 181.3L457.4 286.7C469.9 299.2 490.2 299.2 502.7 286.7C515.2 274.2 515.2 253.9 502.7 241.4L342.7 81.4z"" fill=""currentColor""/>
                 </svg>";
    }

    private string GetDownArrowSvg()
    {
        return @"<svg xmlns=""http://www.w3.org/2000/svg"" viewBox=""0 0 640 640"">
                   <path d=""M297.4 558.6C309.9 571.1 330.2 571.1 342.7 558.6L502.7 398.6C515.2 386.1 515.2 365.8 502.7 353.3C490.2 340.8 469.9 340.8 457.4 353.3L352 458.7L352 88C352 70.3 337.7 56 320 56C302.3 56 288 70.3 288 88L288 458.7L182.6 353.3C170.1 340.8 149.8 340.8 137.3 353.3C124.8 365.8 124.8 386.1 137.3 398.6L297.3 558.6z"" fill=""currentColor""/>
                 </svg>";
    }


    /// <summary>
    /// Handles click on upload placeholder to show contained upload interface
    /// </summary>
    private void OnUploadPlaceholderClick()
    {
        _showContainedUpload = true;
        StateHasChanged();
    }

    /// <summary>
    /// Closes the contained upload modal
    /// </summary>
    private void CloseContainedUpload()
    {
        _showContainedUpload = false;
        StateHasChanged();
    }

    /// <summary>
    /// Handles completion of uploads through the contained upload modal
    /// </summary>
    private async Task OnContainedUploadCompleted(IEnumerable<PhotoSwipeItem> uploadedItems)
    {
        // Close the modal first
        _showContainedUpload = false;

        // Process the uploaded items the same way as regular uploads
        await OnUploadAreaItemsUploaded(uploadedItems);
    }

    public async ValueTask DisposeAsync()
    {
        if (_interop != null && _instanceId != null)
        {
            await _interop.DestroyAsync(_instanceId);
        }

        if (_interop != null)
        {
            await _interop.DisposeAsync();
        }
    }
}